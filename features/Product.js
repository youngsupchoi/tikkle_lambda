const { ExpectedError } = require("./ExpectedError.js");

class OptionCombination {
  constructor({ id, product_id, sales_volume, quantity, db }) {
    this.id = id || null;
    this.product_id = product_id || null;
    this.sales_volume = sales_volume || null;
    this.quantity = quantity || null;
    this.db = db || null;
  }

  static createOptionCombination(product_id, db) {
    try {
      return new OptionCombination({ product_id, db });
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è createOptionCombination : üêû${error}`);
      throw error;
    }
  }

  /**
   * productidÏóê ÎåÄÌïú ÏÉàÎ°úÏö¥ option combinationÏùÑ ÏÉùÏÑ±
   * @param {number} quantity 100000
   * @returns void
   */
  async insertNewOptionCombination(quantity = 100000) {
    try {
      const result = await this.db.executeQuery(`INSERT INTO option_combination (product_id, quantity) values (?, ?)`, [this.product_id, quantity]);
      this.id = result.insertId;
      return;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è insertNewOptionCombination : üêû${error}`);
      throw error;
    }
  }

  /**
   * Ïû¨Í≥†Î•º Í∞êÏÜåÏãúÌÇ§Îäî Ìï®Ïàò
   * @memberof OptionCombination
   * @instance
   * @async
   * @example
   * const option_combination = new OptionCombination({id: 1, db});
   * await option_combination.decreaseQuantity();
   * // => option_combination = {
   * //  id: 1,
   * //  product_id: 1,
   * //  sales_volume: 0,
   * //  quantity: 99,
   * // }
   * @returns {Promise<void>} - A promise that resolves with nothing.
   * @throws {ExpectedError} Throws an ExpectedError with status 500 if the database query fails.
   * @throws {ExpectedError} Throws an ExpectedError with status 400 if the option combination is not valid.
   */

  async decreaseQuantity() {
    try {
      if (this.quantity) {
        this.quantity -= 1;
      }
      const result = this.db.executeQuery(`UPDATE option_combination SET quantity = quantity - 1 WHERE id = ?`, [this.id]);
      if (result.affectedRows === 0) {
        throw error;
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è decreaseQuantity : üêû${error}`);
      throw error;
    }
  }
  /**
   * Ïû¨Í≥†Î•º Ï¶ùÍ∞ÄÏãúÌÇ§Îäî Ìï®Ïàò
   * @memberof OptionCombination
   * @instance
   * @async
   * @example
   * const option_combination = new OptionCombination({id: 1, db});
   * await option_combination.increaseQuantity();
   * // => option_combination = {
   * //  id: 1,
   * //  product_id: 1,
   * //  sales_volume: 0,
   * //  quantity: 101,
   * // }
   * @returns {Promise<void>} - A promise that resolves with nothing.
   * @throws {ExpectedError} Throws an ExpectedError with status 500 if the database query fails.
   * @throws {ExpectedError} Throws an ExpectedError with status 400 if the option combination is not valid.
   */
  async increaseQuantity() {
    try {
      if (this.quantity) {
        this.quantity += 1;
      }
      const result = this.db.executeQuery(`UPDATE option_combination SET quantity = quantity + 1 WHERE id = ?`, [this.id]);
      if (result.affectedRows === 0) {
        throw error;
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è decreaseQuantity : üêû${error}`);
      throw error;
    }
  }
}

class ProductOption {
  constructor({ id, category, option, additional_amount, is_deleted }) {
    this.id = id || null;
    this.category = category;
    this.option = option;
    this.additional_amount = additional_amount;
    this.is_deleted = is_deleted || 0;
  }

  /**
   * Ìï¥Îãπ ÏòµÏÖòÏù¥ Ïù¥ÎØ∏ ÏóÖÎ°úÎìú ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
   * @returns bool
   */
  checkIsUploaded() {
    try {
      if (this.id === null) {
        return false;
      }
      if (this.id !== null) {
        return true;
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è checkIsUploaded : üêû${error}`);
      throw error;
    }
  }
}
class ProductOptions {
  constructor({ product_id, product_option_list, db }) {
    this.product_id = product_id;
    //TODO: formatted_optinosÎ°ú ÏàòÏ†ï
    this.formatted_option = null;
    this.product_option_list = product_option_list || null;
    this.db = db;
  }

  //ÏòµÏÖò Í∞ùÏ≤¥Î•º Î∞õÏïÑÏÑú ÏòµÏÖòÏùÑ ÏóÖÎç∞Ïù¥ÌÑ∞
  // ÌòÑÏû¨ Í∞ÄÏßÄÍ≥† ÏûàÎäî ÏòµÏÖò Í∞ùÏ≤¥Î°ú dbÏóÜÎç∞Ïù¥Ìä∏
  // ÌäπÏ†ï product_idÏóê ÎåÄÌï¥ ÏòµÏÖòÏùÑ Í∞ÄÏ†∏Ïò§Í∏∞
  // option_listÎ•º Î∞õÏïÑÏÑú ÏòµÏÖò ÌòïÌÉúÎ°ú ÏàòÏ†ï
  // ÌòÑÏû¨ Í∞ÄÏßÄÍ≥† ÏûàÎäî ÏòµÏÖò Í∞ùÏ≤¥Î°ú dbÏ∂îÍ∞Ä

  /**
   * ÏÉÅÌíàÏùò Î™®Îì† ÏòµÏÖòÏùÑ Í∞ÄÏ†∏ÏôÄ listÎ°ú Î∞òÌôò
   * @returns
   */
  async loadProductOptions() {
    try {
      const rows = await this.db.executeQuery(`SELECT * FROM product_option WHERE product_id = ?;`, [this.product_id]);
      this.product_option_list = rows;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è loadProductOptions : üêû${error}`);
      throw error;
    }
  }
  /**
   * Ïù¥ÎØ∏ ÏÑúÎ≤ÑÏÉÅÏóê Ï°¥Ïû¨ÌïòÎäî ÏòµÏÖòÏù∏ÏßÄ ÌôïÏù∏
   * @returns bool
   */
  async checkIsUploaded() {
    try {
      for (const options of Object.values(this.formatted_option)) {
        // Î∞∞Ïó¥ ÎÇ¥ Ïñ¥Îñ§ Í∞ùÏ≤¥ÎùºÎèÑ idÍ∞Ä nullÏù¥ ÏïÑÎãàÎ©¥ false Î∞òÌôò
        if (options.some((option) => option.checkIsUploaded())) {
          return true;
        }
      }
      // Î™®Îì† Í∞ùÏ≤¥Ïùò idÍ∞Ä nullÏù∏ Í≤ΩÏö∞
      return false;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è checkIsUploaded : üêû${error}`);
      throw error;
    }
  }
  /**
   * productOptionÏùÑ dbÏÉÅÏóê ÏóÖÎ°úÎìú
   * 1. Í∞Å ÏòµÏÖòÏùÑ ÏóÖÎ°úÎìú
   * 2. Í∞Å ÏòµÏÖò Í∞ØÏàòÏóê ÎßûÎäî option combinationÏÉùÏÑ±
   * 3. Í∞Å option combinationÏóê ÎßûÎäî option combination detailÏÉùÏÑ±
   */
  async uploadProductOptions() {
    try {
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è uploadProductOptions : üêû${error}`);
      throw error;
    }
  }
  getFormattedOption() {
    try {
      if (this.formatted_option === null) {
        throw new ExpectedError({
          status: "500",
          message: `product.loadProductOptions()Î•º Î®ºÏ†Ä Ïã§ÌñâÌï¥ÏïºÌï©ÎãàÎã§.`,
          detail_code: "00",
        });
      }
      return this.formatted_option;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è getFormattedOption : üêû${error}`);
      throw error;
    }
  }

  formatOptionList() {
    try {
      if (this.product_option_list === null) {
        throw new ExpectedError({
          status: "500",
          message: `product_option_listÍ∞Ä Î®ºÏ†Ä Ï±ÑÏõåÏ†∏ÏûàÏñ¥ÏïºÌï©ÎãàÎã§.`,
          detail_code: "00",
        });
      }
      const option_category_dict = {};

      this.product_option_list.forEach((option) => {
        // ÏòµÏÖòÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÏ∂ú
        const category = option.category;
        // Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏÇ¨Ï†ÑÏóê ÏïÑÏßÅ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏúºÎ©¥ Ï¥àÍ∏∞Ìôî
        if (!option_category_dict[category]) {
          option_category_dict[category] = [];
        }

        // Ìï¥Îãπ Ïπ¥ÌÖåÍ≥†Î¶¨ Î¶¨Ïä§Ìä∏Ïóê ÏòµÏÖò Ï∂îÍ∞Ä
        option_category_dict[category].push(new ProductOption(option));
      });
      this.formatted_option = option_category_dict;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è formatOptionListOnlyEssential : üêû${error}`);
      throw error;
    }
  }
}

class Brand {
  constructor({ id, brand_name, is_deleted, db }) {
    this.id = id || null;
    this.brand_name = brand_name || null;
    this.is_deleted = is_deleted || null;
    this.db = db || null;
  }
  toJSON() {
    return {
      id: this.id,
      brand_name: this.brand_name,
      is_deleted: this.is_deleted,
      // Îã§Î•∏ ÌîÑÎ°úÌçºÌã∞Îì§ÎèÑ Ìè¨Ìï®ÏãúÌÇµÎãàÎã§.
    };
  }

  static async checkBrandNameList(brand_name_list, db) {
    try {
      //brand_name_listÏóêÏÑú Ï§ëÎ≥µÏùÑ Ï†úÍ±∞
      brand_name_list = [...new Set(brand_name_list)];
      //Í∏∞Ï°¥Ïóê Ï°¥Ïû¨ÌïòÎäî Î∏åÎûúÎìúÏù∏ÏßÄ ÌôïÏù∏
      const placeholders = brand_name_list.map(() => "?").join(", ");
      // ÏøºÎ¶¨Î•º Ïã§ÌñâÌï† Îïå placeholdersÎ•º ÏÇ¨Ïö©ÌïòÍ≥† Î∞∞Ïó¥Ïùò ÏöîÏÜåÎì§ÏùÑ Ï†ÑÎã¨Ìï©ÎãàÎã§.
      const result = await db.executeQuery(`SELECT * FROM brands WHERE brand_name IN (${placeholders})`, [...brand_name_list]);
      //Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäîÎ∏åÎûúÎìúÎäî ÏÉàÎ°ú ÏÉùÏÑ±
      let brand_obj_list = [];

      for (const brand_name of brand_name_list) {
        const brandExists = result.some((brand) => brand.brand_name === brand_name);
        if (!brandExists) {
          const temp_result = await db.executeQuery(`INSERT INTO brands (brand_name) VALUES (?)`, [brand_name]);
          const newBrand = new Brand({ id: temp_result.insertId, brand_name: brand_name, db });
          const newBrandObj = newBrand.toJSON();
          brand_obj_list.push(newBrandObj);
        } else {
          const brand = result.find((brand) => brand.brand_name === brand_name);
          const existingBrand = new Brand({ id: brand.id, brand_name: brand_name, db });
          const existingBrandObj = existingBrand.toJSON();
          brand_obj_list.push(existingBrandObj);
        }
      }

      return brand_obj_list;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è checkBrandNameList : üêû${error}`);
      throw error;
    }
  }
}

class Product {
  constructor({ id, name, price, description = null, category_id, thumbnail_image, brand_id, created_at, views, is_deleted, wishlist_count, images, db }) {
    this.id = id || null;
    this.name = name || null;
    this.price = price || null;
    this.description = description || null;
    this.category_id = category_id || null;
    this.brand_id = brand_id || null;
    this.created_at = created_at || null;
    this.views = views || null;
    this.is_deleted = is_deleted || null;
    this.wishlist_count = wishlist_count || null;
    this.thumbnail_image = thumbnail_image || null;
    this.images = images || null;
    this.product_options = id === null ? null : new ProductOptions({ product_id: id, db: db });
    this.selected_options = null;
    this.selected_option_combination = null;
    this.db = db;
  }

  /**
   * ÏÉÅÌíàÏù¥ Í∞ñÍ≥†ÏûàÎäî Î™®Îì† ÏòµÏÖòÏùÑ Î°úÎìúÌïòÍ≥† Ìï¥Îãπ ÏòµÏÖòÏùÑ product_optionsÏóê Ï†ÄÏû•ÌïúÎã§.
   * @memberof Product
   */
  async loadProductOptions() {
    try {
      await this.product_options.loadProductOptions();
      this.product_options.formatOptionList();

      const query = `SELECT * FROM product_option WHERE product_id = ?`;
      const product_options = await this.db.executeQuery(query, [this.id]);
      return;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è loadProductOptions : üêû${error}`);
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  }

  async uploadProduct() {
    try {
      const result = await this.db.executeQuery(
        `INSERT INTO products (name, price, description, category_id, brand_id, views, is_deleted, thumbnail_image, images) values (?, ?, ?, ?, ?, ?, ?, ?, ?)`
      );
      this.id = result.insertId;
      return;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è uploadProduct : üêû${error}`);
      throw error;
    }
  }
  //selected optionÏù¥ Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî optionÏù∏ÏßÄ Í≤ÄÏ¶ùÌïòÎäî Ìï®Ïàò
  validateProductOption(selectedOption) {
    try {
      for (const [category, option] of Object.entries(selectedOption)) {
        // ÏÑ†ÌÉùÎêú ÏòµÏÖòÏùò Ïπ¥ÌÖåÍ≥†Î¶¨ÏôÄ ÏùºÏπòÌïòÎäî Ï†úÌíà ÏòµÏÖòÏùÑ Ï∞æÎäîÎã§.
        const formatted_option = this.product_options.getFormattedOption();
        // ÏùºÏπòÌïòÎäî Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏóÜÏúºÎ©¥, ÏÑ†ÌÉùÎêú ÏòµÏÖòÏùÄ Ïú†Ìö®ÌïòÏßÄ ÏïäÎã§.
        if (category in Object.keys(formatted_option)) {
          throw new ExpectedError({
            status: "400",
            message: `Ìï¥Îãπ ÏòµÏÖòÏùÄ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
            detail_code: "01",
          });
        }
        // ÏùºÏπòÌïòÎäî Ïπ¥ÌÖåÍ≥†Î¶¨Í∞Ä ÏûàÎã§Î©¥, ÏÑ†ÌÉùÎêú ÏòµÏÖòÏù¥ Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ÌïúÎã§.
        if (!formatted_option[category].some((productOption) => productOption.option === option)) {
          throw new ExpectedError({
            status: "400",
            message: `Ìï¥Îãπ ÏòµÏÖòÏùÄ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
            detail_code: "01",
          });
        }
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è validateProductOption : üêû${error}`);
      throw error;
    }
  }

  // ÏÑ†ÌÉùÌïú option_combinationÏùò Ïû¨Í≥†Í∞Ä ÎÇ®ÏïÑÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Ìï®Ïàò
  /**
   * ÏÑ†ÌÉùÌïú ÏòµÏÖò Ï°∞Ìï©Ïùò Ïû¨Í≥†Í∞Ä ÎÇ®ÏïÑÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Ìï®Ïàò
   * @memberof Product
   * @instance
   * @async
   * @example
   * const product = await Product.createById(1);
   * await product.loadSelectedProductOptionCombination();
   * product.validateProductOptionCombination();
   * // => product.selected_option_combination = {
   * //  id: 1,
   * //  sales_volume: 0,
   * //  quantity: 100,

   * // }
   * @returns {Promise<void>} - A promise that resolves with nothing.
   * @throws {ExpectedError} Throws an ExpectedError with status 400 if the selected option combination is not valid.
   */
  validateProductOptionCombination() {
    if (this.selected_option_combination.quantity === 0) {
      throw new ExpectedError({
        status: "400",
        message: `Ìï¥Îãπ ÏòµÏÖò Ï°∞Ìï©Ïùò Ïû¨Í≥†Í∞Ä ÏóÜÏäµÎãàÎã§.`,
        detail_code: "02",
      });
    }
  }

  //TODO: ÏÑúÎ∏åÏøºÎ¶¨ ÏÇ¨Ïö©ÌïòÏó¨ ÏµúÏ†ÅÌôî ÏöîÌï®
  async loadSelectedProductOptionCombination() {
    try {
      const selected_option_values = Object.values(this.selected_options);
      const count = selected_option_values.length;
      const formattedValues = selected_option_values.map((val) => `'${val}'`).join(", ");
      const findCombinationQuery = `
          SELECT oc.*
          FROM option_combination AS oc
          INNER JOIN option_combination_detail AS ocd ON oc.id = ocd.combination_id
          INNER JOIN product_option AS po ON po.id = ocd.option_id
          WHERE po.option IN (${formattedValues}) AND oc.product_id = ?
          GROUP BY oc.id
          HAVING COUNT(*) = ?;
        `;

      const result = await this.db.executeQuery(findCombinationQuery, [this.id, count]);
      if (result.length === 0) {
        throw new ExpectedError({
          status: "400",
          message: `Ìï¥Îãπ ÏòµÏÖò Ï°∞Ìï©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
          detail_code: "01",
        });
      }

      const option_combination = new OptionCombination({ ...result[0], db: this.db });
      this.selected_option_combination = option_combination;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è loadSelectedProductOptionCombination : üêû${error}`);
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  }

  //productÏùò Í∞ÄÍ≤©ÏùÑ Í≥ÑÏÇ∞ÌïòÍ≥† Ìï¥Îãπ Í∞ÄÍ≤©ÏùÑ inputÍ∞íÍ≥º ÎπÑÍµê
  /**
   * ÏÉÅÌíàÏùò Í∞ÄÍ≤©ÏùÑ Í≥ÑÏÇ∞ÌïòÍ≥† Ìï¥Îãπ Í∞ÄÍ≤©ÏùÑ inputÍ∞íÍ≥º ÎπÑÍµêÌïòÎäî Ìï®Ïàò
   * @memberof Product
   * @instance
   * @async
   * @example
   * const product = await Product.createById(1);
   * await product.loadSelectedProductOptionCombination();
   * product.validateProductOptionCombination();
   * product.validateProductPrice(10000);
   * // => product.selected_option_combination = {
   * //  id: 1,
   * //  product_id: 1,
   * //  sales_volume: 0,
   * //  quantity: 100,
   * // }
   * @returns {Promise<void>} - A promise that resolves with nothing.
   * @throws {ExpectedError} Throws an ExpectedError with status 400 if the product price is not valid.
   * @param {number} input_price - The price of the product to validate.
   */
  async validateProductPrice(input_price) {
    try {
      const totalPrice = this.calculateTotalPrice();
      if (totalPrice !== input_price) {
        throw new ExpectedError({
          status: "400",
          message: `ÏÉÅÌíàÏùò Í∞ÄÍ≤©Ïù¥ ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.`,
          detail_code: "03",
        });
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è validateProductPrice : üêû${error}`);
      if (error.status) {
        throw error;
      }
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  }

  async lockProduct() {
    try {
      this.db.executeQuery(`SELECT * FROM products WHERE id = ? FOR UPDATE;`, [this.id]);
    } catch (err) {
      console.error(`üö® error -> ‚ö°Ô∏è lockProductForStartTIkkling : üêû ${err}`);
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  }

  async updateSelectedOption(product_option) {
    this.selected_options = product_option;
  }

  //product_optionÏùò addition_amountÏôÄ selectedoptionÏùÑ Í≥†Î†§ÌïòÏó¨ productÏùò Ï†ÑÏ≤¥ Í∞ÄÍ≤©ÏùÑ Í≥ÑÏÇ∞ÌïòÎäî Ìï®Ïàò
  calculateTotalPrice() {
    try {
      let additionalAmount = 0;
      const formatted_option = this.product_options.getFormattedOption();
      for (const category of Object.keys(formatted_option)) {
        additionalAmount += formatted_option[category].find((option) => {
          return option.option == this.selected_options[category];
        }).additional_amount;
      }
      return this.price + additionalAmount;
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è calculateTotalPrice : üêû${error}`);
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  }

  /**
   * idÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Product Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏÉùÏÑ±ÌïúÎã§.
   * @memberof Product
   * @static
   * @async
   * @example
   * const db = new DBManager();
   * await db.openTransaction();
   * const product = await Product.createById(1, db);
   * // => product = {
   * //  id: 1,
   * //  name: "Ìã∞ÌÅ¥ÎßÅ ÏÉÅÌíà",
   * //  price: 10000,
   * //  description: "Ìã∞ÌÅ¥ÎßÅ ÏÉÅÌíàÏûÖÎãàÎã§.",
   * //  category_id: 1,
   * //  brand_id: 1,
   * //  created_at: "2020-01-01 00:00:00",
   * //  views: 0,
   * //  is_deleted: 0,
   * //  wishlist_count: 0,
   * //  thumbnail_image: "https://tikkle-image.s3.ap-northeast-2.amazonaws.com/1.jpg",
   * //  images: [
   * //    "https://tikkle-image.s3.ap-northeast-2.amazonaws.com/1.jpg",
   * //    "https://tikkle-image.s3.ap-northeast-2.amazonaws.com/2.jpg",
   * //    "https://tikkle-image.s3.ap-northeast-2.amazonaws.com/3.jpg",
   * //  ],
   * //  product_options: [],
   * //  selected_options: null,
   * //  selected_option_combination: null,
   * // }
   * @throws {ExpectedError} Throws an ExpectedError with status 500 if the database query fails.
   * @param {number} id - The id of the product to create.
   * @returns {Promise<Product>} - A promise that resolves with a Product instance.
   */
  static createById = async ({ id, db }) => {
    try {
      const query = `SELECT * FROM products WHERE id = ?`;
      const rows = await db.executeQuery(query, [id]);
      return new Product({ ...rows[0], db });
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è createById : üêû${error}`);
      throw new ExpectedError({
        status: "500",
        message: `ÏÑúÎ≤ÑÏóêÎü¨`,
        detail_code: "00",
      });
    }
  };

  async decreaseProductQuantity() {
    try {
      this.selected_option_combination.decreaseQuantity();
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è decreaseProductQuantity : üêû${error}`);
      throw error;
    }
  }
  async increaseProductSalesVolume() {
    try {
      if (this.sales_volume) {
        this.sales_volume += 1;
      }
      const result = this.db.executeQuery(`UPDATE products SET sales_volume = sales_volume + 1 WHERE id = ?`, [this.id]);
      if (result.affectedRows === 0) {
        throw ExpectedError({
          status: 500,
          detail_code: "00",
          message: "ÏÉÅÌíà ÌåêÎß§Îüâ Ï¶ùÍ∞Ä Ïã§Ìå®",
        });
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è increaseQuantity : üêû${error}`);
      throw error;
    }
  }
  //TODO: Î≤ÑÍ∑∏ ÏÉùÍ≤ºÎäîÏßÄ ÌôïÏù∏
  static async enrollProductList(product_list, db) {
    try {
      for (const product of product_list) {
        const result = await db.executeQuery(`SELECT * FROM products WHERE name = ?`, [product.name]);
        if (result.length == 0) {
          const result_of_insert_product = await db.executeQuery(`INSERT INTO products (name, price, description, category_id, brand_id, thumbnail_image, images) VALUES (?, ?, ?, ?, ?, ?, ?)`, [
            product.name,
            product.price,
            product.description,
            product.category_id,
            product.brand_id,
            product.thumbnail_image,
            product.images,
          ]);
          const result_of_insert_option_combination = await db.executeQuery(`INSERT INTO option_combination (product_id, quantity) VALUES (?, ?)`, [result_of_insert_product.insertId, 10000]);
          const result_of_insert_option = await db.executeQuery(`INSERT INTO product_option (product_id, category, \`option\`, additional_amount) VALUES (?, ?, ?, ?)`, [
            result_of_insert_product.insertId,
            "default",
            "default",
            1,
          ]);

          const result_of_insert_option_combination_detail = await db.executeQuery(`INSERT INTO option_combination_detail (combination_id, option_id) values (?, ?)`, [
            result_of_insert_option_combination.insertId,
            result_of_insert_option.insertId,
          ]);
        }
      }
    } catch (error) {
      console.error(`üö® error -> ‚ö°Ô∏è enrollProductList : üêû${error}`);
      throw error;
    }
  }
}

module.exports = { Product, OptionCombination, Brand };
